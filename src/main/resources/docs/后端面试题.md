#### Java 后端程序员常见面试题（含答案解析）

##### 第一章 Java 基础面试题

1. 问：JDK、JRE、JVM 的区别是什么？

   答：① JDK（Java Development Kit）：Java 开发工具包，包含 JRE 和开发工具（javac、javadoc、jar 等），是开发 Java 程序的核心；② JRE（Java Runtime Environment）：Java 运行时环境，包含 JVM 和核心类库，能运行已编译的 Java 程序；③ JVM（Java Virtual Machine）：Java 虚拟机，负责将字节码文件（.class）解释为对应系统的机器码，实现 “一次编译，到处运行”。三者关系：JDK > JRE > JVM。

   

2. 问：String、StringBuffer、StringBuilder 的区别？

   答：① 可变性：String 是不可变字符串（底层是 final 修饰的 char 数组），每次修改都会创建新对象；StringBuffer 和 StringBuilder 是可变字符串，修改时直接操作原数组。② 线程安全：StringBuffer 线程安全（方法加了 synchronized），效率较低；StringBuilder 线程不安全，效率较高。③ 适用场景：String 适用于少量字符串操作场景；StringBuilder 适用于单线程下大量字符串拼接；StringBuffer 适用于多线程下大量字符串拼接。

   

3. 问：ArrayList 和 LinkedList 的区别及适用场景？

   答：① 底层实现：ArrayList 底层是动态数组（初始容量 10，扩容因子 0.5）；LinkedList 底层是双向链表。② 操作性能：ArrayList 随机访问（get、set）效率高（O (1)），插入、删除效率低（需移动元素，O (n)）；LinkedList 插入、删除效率高（O (1)），随机访问效率低（需遍历链表，O (n)）。③ 适用场景：ArrayList 适用于频繁查询、少量增删的场景；LinkedList 适用于频繁增删、少量查询的场景。

   

4. 问：HashMap 的底层实现原理（JDK1.8 及以后）？

   答：JDK1.8 后 HashMap 底层采用 “数组 + 链表 + 红黑树” 结构。① 数组（Node [] table）：存储键值对节点，每个数组元素是链表或红黑树的头节点；② 哈希计算：通过 key 的 hashCode () 计算哈希值，再经过扰动函数处理后得到数组下标，确定节点存储位置；③ 冲突解决：当多个 key 哈希到同一下标时，形成链表；当链表长度超过 8 且数组长度≥64 时，链表转为红黑树（提升查询效率，从 O (n) 变为 O (logn)）；④ 扩容机制：当元素个数（size）超过阈值（数组长度 × 负载因子 0.75）时，数组扩容为原来的 2 倍，重新哈希分配节点。

   

##### 第二章 JVM 面试题

1. 问：Java 内存模型（JMM）及作用？

   答：Java 内存模型是一套规范，定义了线程如何通过内存进行交互，解决多线程环境下可见性、原子性、有序性问题。① 内存划分：线程工作内存（存储线程私有变量）和主内存（存储共享变量，如实例变量、静态变量）；② 核心特性：可见性（volatile 关键字保证，修改后立即同步到主内存，读取时从主内存加载）、原子性（synchronized、Lock 或原子类保证）、有序性（禁止指令重排，volatile 和 synchronized 可保证）；③ 作用：避免多线程操作共享变量时出现脏读、不可重复读等问题，确保线程安全。

   

2. 问：垃圾回收（GC）的核心流程？

   答：GC 是 JVM 自动回收无用对象内存的过程，核心流程分三步：① 标记：通过可达性分析（以 GC Roots 为起点，如线程栈引用、静态变量引用）标记出存活对象，未被标记的为垃圾对象；② 清除：回收垃圾对象占用的内存，释放空间；③ 整理：解决内存碎片问题（复制算法、标记 - 整理算法会进行此步骤），使存活对象连续存储，便于后续内存分配。常见垃圾收集算法：标记 - 清除（效率低、有碎片）、复制（无碎片、效率高，适用于年轻代）、标记 - 整理（适用于老年代）。

   

3. 问：类加载的过程是什么？双亲委派模型的作用？

   答：① 类加载过程：加载（读取.class 文件到内存，生成 Class 对象）→ 验证（校验字节码合法性，防止恶意文件）→ 准备（为静态变量分配内存，设置默认值）→ 解析（将符号引用转为直接引用）→ 初始化（执行静态代码块、为静态变量赋值）。② 双亲委派模型：类加载器加载类时，先委托父类加载器加载，父类无法加载时再由子类加载器自己加载。作用：① 避免类重复加载；② 保证核心类库安全（如 java.lang.String 无法被自定义类篡改）。

   

##### 第三章 并发编程面试题

1. 问：synchronized 和 volatile 的区别？

   答：① 作用范围：synchronized 可修饰方法、代码块，作用于对象或类；volatile 修饰变量，作用于单个变量。② 核心特性：synchronized 保证原子性、可见性、有序性；volatile 仅保证可见性和有序性，不保证原子性。③ 实现原理：synchronized 基于对象监视器（monitor）实现，JDK1.6 后优化为偏向锁、轻量级锁、重量级锁；volatile 通过内存屏障（Memory Barrier）禁止指令重排，保证变量修改后立即同步到主内存。④ 适用场景：synchronized 适用于多线程原子性操作（如计数器递增）；volatile 适用于变量状态标记（如停止线程的 flag 变量）。

   

2. 问：线程池的核心参数及工作原理？

   答：① 核心参数（ThreadPoolExecutor）：核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、空闲线程存活时间（keepAliveTime）、时间单位（unit）、任务队列（workQueue）、线程工厂（threadFactory）、拒绝策略（handler）。② 工作原理：1. 当线程数＜核心线程数时，创建核心线程执行任务；2. 线程数达到核心线程数，任务放入队列等待；3. 队列满且线程数＜最大线程数时，创建非核心线程执行任务；4. 线程数达到最大线程数且队列满，执行拒绝策略（默认 AbortPolicy，抛出异常）。常见拒绝策略：AbortPolicy（抛异常）、CallerRunsPolicy（由调用线程执行）、DiscardPolicy（丢弃任务）、DiscardOldestPolicy（丢弃队列最旧任务）。

   

3. 问：ThreadLocal 的原理及使用场景？

   答：① 原理：ThreadLocal 为每个线程提供独立的变量副本，线程操作副本时不影响其他线程。底层通过 Thread 类中的 ThreadLocalMap（键为 ThreadLocal 对象，值为变量副本）实现，每个线程持有自己的 ThreadLocalMap。② 核心方法：set（设置副本值）、get（获取副本值）、remove（移除副本值，避免内存泄漏）。③ 注意事项：ThreadLocal 可能导致内存泄漏（ThreadLocalMap 的 Entry 持有 ThreadLocal 弱引用，线程存活时 Entry 不会被回收），需在使用后调用 remove () 清理。④ 适用场景：Spring 事务管理（存储事务上下文）、日期格式化工具（避免多线程竞争）、Web 开发中存储用户会话信息。

   

##### 第四章 Spring 生态面试题

1. 问：Spring IoC 容器的核心原理？

   答：IoC（Inversion of Control，控制反转）是 Spring 核心思想，即将对象的创建、依赖注入的控制权从业务代码转移到 Spring 容器。① 核心流程：1. 加载配置（XML / 注解），解析出需要创建的 Bean 信息；2. 实例化 Bean（通过构造方法、工厂方法）；3. 依赖注入（DI，将 Bean 的依赖对象注入到当前 Bean 中）；4. Bean 初始化（执行 init-method、@PostConstruct 注解方法）；5. Bean 就绪，供应用调用；6. 容器关闭时，执行 destroy-method、@PreDestroy 注解方法销毁 Bean。② 依赖注入方式：构造器注入、setter 注入、字段注入（@Autowired，不推荐，存在循环依赖风险）。

   

2. 问：Spring AOP 的实现原理？

   答：AOP（Aspect-Oriented Programming，面向切面编程）通过动态代理机制，在不修改业务代码的前提下为方法添加增强逻辑（日志、事务、权限）。① 核心概念：切面（Aspect，封装增强逻辑的类）、通知（Advice，增强逻辑的具体方法，如前置通知、后置通知、环绕通知）、切入点（Pointcut，指定增强的方法范围）、连接点（JoinPoint，所有可被增强的方法）。② 实现方式：1. JDK 动态代理：基于接口实现，通过 Proxy.newProxyInstance () 创建代理对象，仅能代理接口方法；2. CGLIB 动态代理：基于继承实现，通过 Enhancer 创建代理对象，可代理类和接口方法，性能优于 JDK 代理（需引入 CGLIB 依赖）。Spring AOP 默认优先使用 JDK 动态代理，无接口时使用 CGLIB 代理。

   

3. 问：Spring 事务的隔离级别和传播行为？

   答：① 隔离级别（解决并发事务问题）：1. DEFAULT（默认，继承数据库隔离级别）；2. READ_UNCOMMITTED（读未提交，存在脏读、不可重复读、幻读）；3. READ_COMMITTED（读已提交，避免脏读，存在不可重复读、幻读，MySQL 默认）；4. REPEATABLE_READ（可重复读，避免脏读、不可重复读，存在幻读，InnoDB 通过 MVCC 解决幻读）；5. SERIALIZABLE（串行化，完全避免并发问题，效率最低）。② 传播行为（解决事务嵌套问题）：1. REQUIRED（默认，当前无事务则创建新事务，有则加入当前事务）；2. SUPPORTS（当前有事务则加入，无则以非事务方式执行）；3. MANDATORY（当前必须有事务，否则抛异常）；4. REQUIRES_NEW（无论当前有无事务，都创建新事务）；5. NOT_SUPPORTED（以非事务方式执行，当前有事务则挂起）；6. NEVER（以非事务方式执行，当前有事务则抛异常）；7. NESTED（嵌套事务，当前事务存在时，在嵌套事务中执行，嵌套事务独立提交 / 回滚）。

   

##### 第五章 数据库与分布式面试题

1. 问：MySQL 索引的类型及底层原理？

   答：① 索引类型：1. 主键索引（PRIMARY KEY）：唯一标识记录，不可为空，一张表仅一个；2. 唯一索引（UNIQUE）：索引值唯一，可为空；3. 普通索引（INDEX）：无唯一性约束，加速查询；4. 联合索引（多列组合索引）：遵循 “最左前缀匹配原则”；5. 全文索引（FULLTEXT）：用于全文检索。② 底层原理：MySQL 主流存储引擎 InnoDB 默认使用 B + 树索引。B + 树是平衡多路查找树，特点：① 叶子节点存储所有数据，按顺序排列，便于范围查询；② 非叶子节点仅存储索引值，减少磁盘 IO；③ 支持聚簇索引（主键索引，叶子节点存储整行数据）和非聚簇索引（普通索引，叶子节点存储主键值，需回表查询）。

   

2. 问：Redis 的数据结构及应用场景？

   答：① 字符串（String）：存储字符串、数字，适用于缓存用户信息、计数器、分布式锁（SETNX）。② 哈希（Hash）：存储键值对集合，适用于缓存对象（如用户详情、商品信息），可单独修改对象字段。③ 列表（List）：有序可重复，底层是双向链表，适用于消息队列、排行榜（最新消息）、好友列表。④ 集合（Set）：无序不可重复，支持交集、并集、差集运算，适用于好友推荐、去重、点赞统计。⑤ 有序集合（Sorted Set）：有序不可重复，每个元素关联分数，适用于排行榜（按分数排序）、延时任务。⑥ 其他结构：Geo（地理位置）、HyperLogLog（基数统计）、BitMap（位运算，适用于签到、在线状态）。

   

3. 问：分布式锁的实现方案及优缺点？

   答：① Redis 实现分布式锁：核心命令 SET key value NX EX timeout（NX 保证唯一获取锁，EX 设置过期时间）。优点：性能高、实现简单；缺点：需处理锁过期续约、释放锁误删（需校验锁 value）、集群环境下一致性问题（RedLock 算法优化）。② ZooKeeper 实现分布式锁：基于临时有序节点，客户端创建节点，最小序号节点获取锁，释放锁时删除节点，其他节点监听前驱节点。优点：一致性强、自动释放锁（会话过期）；缺点：性能低于 Redis，部署维护复杂。③ 数据库实现分布式锁：基于唯一索引（插入数据获取锁，删除释放锁）。优点：实现简单、无需额外中间件；缺点：性能差、存在死锁风险（需设置过期时间）。适用场景：高性能场景选 Redis，高一致性场景选 ZooKeeper。